"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  ArtifactExistsRequest: () => ArtifactExistsRequest,
  ArtifactGetRequest: () => ArtifactGetRequest,
  ArtifactPutRequest: () => ArtifactPutRequest,
  createClient: () => createClient
});
module.exports = __toCommonJS(src_exports);

// package.json
var package_default = {
  name: "@vercel/remote",
  version: "1.0.1",
  description: "An SDK for remote artifact caching on Vercel",
  main: "dist/index.js",
  types: "dist/index.d.ts",
  files: [
    "dist"
  ],
  scripts: {
    test: "vitest run",
    lint: "eslint src/**/*.ts",
    typecheck: "tsc -p tsconfig.json --noEmit",
    build: "tsup",
    dev: "tsup --watch",
    "clean:build": "rm -rf dist"
  },
  repository: {
    type: "git",
    url: "git+https://github.com/vercel/remote-cache.git"
  },
  keywords: [],
  author: "Jared Palmer",
  license: "MPL-2.0",
  bugs: {
    url: "https://github.com/vercel/remote-cache/issues"
  },
  homepage: "https://github.com/vercel/remote-cache#readme",
  devDependencies: {
    "@types/concat-stream": "^2.0.0",
    "@types/node": "12.20.24",
    "@types/node-fetch": "^2.6.2",
    "@types/raw-body": "^2.3.0",
    "async-listen": "^2.0.2",
    esbuild: "^0.14.21",
    msw: "^0.36.8",
    tsconfig: "workspace:^",
    vitest: "^0.3.2"
  },
  dependencies: {
    "ci-info": "^3.4.0",
    "concat-stream": "^2.0.0",
    "node-fetch": "^2.6.7",
    "raw-body": "^2.5.1"
  }
};

// src/utils/user-agent.ts
function getUserAgent(product) {
  return `vercel/remote ${package_default.version} ${product} node${process.version} ${process.platform} (${process.arch})`;
}

// src/artifact-request.ts
var import_stream = require("stream");
var import_node_fetch = __toESM(require("node-fetch"));
var import_raw_body = __toESM(require("raw-body"));
var import_ci_info = __toESM(require("ci-info"));

// src/utils/stream-to-buffer.ts
var import_concat_stream = __toESM(require("concat-stream"));
async function streamToBuffer(stream) {
  return new Promise((resolve, reject) => {
    stream.on("error", reject);
    stream.pipe((0, import_concat_stream.default)(resolve));
  });
}

// src/artifact-request.ts
var ArtifactBaseRequest = class {
  constructor(token, url, userAgent, options) {
    this.url = url;
    this.token = token;
    this.userAgent = userAgent;
    this.options = options;
  }
  getHeaders(method, options) {
    const headers = {
      Authorization: `Bearer ${this.token}`,
      "User-Agent": this.userAgent
    };
    if (method === "PUT") {
      headers["Content-Type"] = "application/octet-stream";
      if ((options == null ? void 0 : options.duration) !== void 0) {
        headers["x-artifact-duration"] = String(options.duration);
      }
      if ((options == null ? void 0 : options.tag) !== void 0) {
        headers["x-artifact-tag"] = options.tag;
      }
    }
    if (import_ci_info.default.name) {
      headers["x-artifact-client-ci"] = import_ci_info.default.name;
    }
    headers["x-artifact-client-interactive"] = process.stdout.isTTY ? "1" : "0";
    return headers;
  }
};
var ArtifactPutRequest = class extends ArtifactBaseRequest {
  async stream(artifact) {
    const body = await streamToBuffer(artifact);
    const res = await (0, import_node_fetch.default)(this.url, {
      method: "PUT",
      headers: this.getHeaders("PUT", this.options),
      body
    });
    this.response = res;
    if (!res.ok) {
      const error = await res.text();
      throw new Error(error);
    }
  }
  async buffer(artifact) {
    const res = await (0, import_node_fetch.default)(this.url, {
      method: "PUT",
      headers: this.getHeaders("PUT", this.options),
      body: artifact
    });
    this.response = res;
    if (!res.ok) {
      const error = await res.text();
      throw new Error(error);
    }
  }
};
var ArtifactGetRequest = class extends ArtifactBaseRequest {
  async stream() {
    const res = await (0, import_node_fetch.default)(this.url, {
      method: "GET",
      headers: this.getHeaders("GET")
    });
    this.response = res;
    if (!res.ok) {
      const error = await res.text();
      throw new Error(error);
    }
    return import_stream.Readable.from(res.body);
  }
  async buffer() {
    const res = await (0, import_node_fetch.default)(this.url, {
      method: "GET",
      headers: this.getHeaders("GET")
    });
    this.response = res;
    if (!res.ok) {
      const error = await res.text();
      throw new Error(error);
    }
    const r = import_stream.Readable.from(res.body);
    try {
      return await (0, import_raw_body.default)(r, {
        length: res.headers.get("Content-Length")
      });
    } catch (err) {
      throw new Error(
        `Error downloading artifact: Mismatched content length on response.`
      );
    }
  }
};
var ArtifactExistsRequest = class extends ArtifactBaseRequest {
  async send() {
    const res = await (0, import_node_fetch.default)(this.url, {
      method: "HEAD",
      headers: this.getHeaders("HEAD")
    });
    this.response = res;
    if (res.status === 200) {
      return true;
    }
    if (res.status === 404) {
      return false;
    }
    if (res.status === 403 || res.status === 401) {
      throw new Error(
        JSON.stringify({
          error: {
            code: "forbidden",
            message: "Not authorized"
          }
        })
      );
    }
    throw new Error(`Unexpected status code: ${res.status}`);
  }
};

// src/constants.ts
var REMOTE_CACHE_ENDPOINT = "https://vercel.com/api/v8/artifacts";

// src/remote-cache-client.ts
var RemoteClientImpl = class {
  constructor(token, { teamId, product }) {
    this.token = token;
    this.teamId = teamId;
    this.userAgent = getUserAgent(product);
  }
  endpointURL(hash) {
    if (hash.includes("/")) {
      throw new Error("Invalid hash: Cannot contain '/'");
    }
    const params = this.teamId ? `?teamId=${this.teamId}` : "";
    return `${REMOTE_CACHE_ENDPOINT}/${hash}${params}`;
  }
  get(hash, options) {
    return new ArtifactGetRequest(
      this.token,
      this.endpointURL(hash),
      this.userAgent,
      options
    );
  }
  put(hash, options) {
    return new ArtifactPutRequest(
      this.token,
      this.endpointURL(hash),
      this.userAgent,
      options
    );
  }
  exists(hash, options) {
    return new ArtifactExistsRequest(
      this.token,
      this.endpointURL(hash),
      this.userAgent,
      options
    );
  }
};

// src/index.ts
function createClient(token, options) {
  return new RemoteClientImpl(token, options);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ArtifactExistsRequest,
  ArtifactGetRequest,
  ArtifactPutRequest,
  createClient
});
